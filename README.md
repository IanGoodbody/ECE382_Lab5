# Lab 5
# Remote Interfacing

## Objectives

The focus of this lab was to interface an inferred remote control with the MSP430. Basic functionality called for 
using the remote control to toggle the MSP430 launchpad LEDs while more advanced functionality required interfacing 
with both the remote control and the Nokia display to implment either the pong game or etch-a-sketch from earilier labs.

## Prelab
### Remote Reverse Engineering

The primary funciton of the pre-design work was to understand how the IR remote control sent different data signals, and 
how the IR sensor that was connected to the MSP430 would interpret these signals. The experiment used to determine how
the IR remote functioned involved connecting an IR signal sensor to the MSP430 and to a logic analizer to measure both 
the time of each compomnent of the signal wave, as well as the timer A counts for the timer setup used throughout the 
project, 1/8 prescaler, count-up, with the overflow register set to `0xFFFF`. The testing [C file](http://www.ece382.com/labs/lab5/start5.c) 
and [header](http://www.ece382.com/labs/lab5/start5.h) can be found on the course websight under lab 5. The test was
set up with the IR sensor connected as it is in the generic schematic for this lab: VCC and GND connected to the 
corresponding launchpad pins, and the output signal wired to pin 2.6.

Data was taken from 11 seperate samples by reading the waveform from the logic analyzer as well as the timer counting 
array generated by the provided code. Every test involved sampling from the waveform generated by a power button press. 

![alt text](https://raw.githubusercontent.com/IanGoodbody/ECE382_Lab5/master/L5_PWR_Wave.jpg "Example wave output")

The waveform above gives the general anatomy of the signal generated by the specific remote used. The sensor output idles
at 1 until the falling edge of the inital start wave at the trigger. This start wave stands out with a fairly long
signal durration. Following the start wave, comes a series of fiarly constant 0 pulses and 1 pulses of either a 
consistantly long or consistantly short durration. What these long or short pulses were origionally designed to 
or what order they were intended bo be given (LSB first or MSB first) has no effect on the design of this lab as long
as the standard used to analize these bits thorughout the lab were consistant. In this light the short 1 pulses were 
defined as 0 signal, and the long 1 pulses were designated as 1 signals. Data was oritionally interpreted as the MSB 
recieved first, however later analysis showed that reading the data LSB first produced a more logical pattern in bit 
codes and so that standard is represented here and in the actual implementation of the lab. The last useful wave signal
is a standard 0 pulse similar to those of the data pulses, followed by a very long high signal. This was interpreted as
the end of transmition signal.

The samples taken from the power button press were taken durring 11 seperate trials for each the timing data and the 
timer count data. For the timing data, the times that corresponded to the data signals were taken from random waveforms
within the logic analizer signal. Conversely, the timer count data was only taken from single points on the waveform.
As can be seen in the data tables below, this sampling method for the timer counts produced slightly narrower error 
that were awkward when implemented in the code. The tables below give the means, standard deviations, and error margins
for the different signal time and timer counts analyzed. The actual data is given in the xcel sheets are included with
the code.

##### Table 1: Logic Analizer Timing Samples
Values are given in miliseconds
|Measure |Start Low|Start High|Data 1 Low|Data 1 High|Data 0 Low|Data 0 High|Stop Low|Stop High|
|:------:|:-------:|:--------:|:--------:|:---------:|:--------:|:---------:|:------:|:-------:|
|Mean    | 9.024   | 4.439    | 0.605    | 1.647     | 0.594    | 0.522     | 0.619  | 39.779  |
|Std Dev | 0.020   | 0.021    | 0.016    | 0.019     | 0.019    | 0.016     | 0.024  | 0.024   |
|Max     | 9.100   | 4.519    | 0.665    | 1.719     | 0.666    | 0.581     | 0.708  | 39.868  |
|Min     | 8.949   | 4.359    | 0.544    | 1.575     | 0.521    | 0.464     | 0.529  | 39.690  |


##### Table 2: Timer Counts
Values are recorded from TAR, units of counts
|Measure |Start Low|Start High|Data 1 Low|Data 1 High|Data 0 Low|Data 0 High|Stop Low|Stop High|
|:------:|:-------:|:--------:|:--------:|:---------:|:--------:|:---------:|:------:|:-------:|
|Mean    | 8918    | 4394     | 599      | 1618      | 581      | 529       | 598    | 39334   |
|Std Dev | 24.03   | 21.78    | 30.24    | 25.32     | 12.47    | 10.72     | 19.62  | 24.69   |
|Max     | 9007    | 4475     | 712      | 1712      | 628      | 569       | 671    | 39426   |
|Min     | 8828    | 4312     | 486      | 1523      | 534      | 488       | 524    | 39242   |

##### Table 3: Button codes
Values were interpreted from the logical analizer waveforms
|Button| Hex Code|
|:-:|:-:|
|0|

The statistical analysis of the data to generate the confidence interevals took advantage of the fact that most error
distributions are approximately normal (the data sets are too small to deffinitively show a normal distribution so the 
a priori assumption must suffice). The intereval was then designed to include 99.99% of the signals that came into
the sensor using the formula:
$$\mu \pm z_{crit} * \sigma$$
